---
title: 'Problem Set 03'
author: "Your Name Here: Group X"
date: 'Last updated: `r Sys.Date()`'
format:
  html:
    toc: true
    number-depth: 3
    toc-location: left
    embed-resources: true
---


```{r}
#| label: setup
#| message: false
#| warning: false

## FIXME
library(tidyverse)
library(readxl)
library(cowplot)
theme_set(theme_cowplot())
```


## Size Dimorphism in Spiders

Sexual size dimorphism (SSD) refers to the difference in size between males and females of the same species. Spiders show some of the most dramatic cases where females are larger than males.

The golden silk orb weaver (*Nephila clavipes*) is a species of spider that shows extreme SSD, in which males are about 2/3 smaller than females. This picture shows the size disparity between a female and male:

![](https://cdn.shopify.com/s/files/1/0841/0073/products/il_570xN.917073770_s7se.jpg){width=50% fig-align="center" fig-alt="Image of a female and male golden silk orb weaver showing size dimorphism."}

In contrast, in the wolf spider (*Pardosa ramulosa*), males and females do not show large size differences.

![](https://crawford.tardigrade.net/journal/album/fordramulosa.jpg){width=50% fig-align="center" fig-alt="Image of wolf spiders showing no size dimorphism."}

The file `Size_Dimorphism.xlsx` contains data on body mass and body length for males and females in these two species.


## Data Validation and Cleaning

One of the first steps in analysis is to make sure that the data you loaded into R is the data that you think you recorded, that all the groups are present in the correct counts, that there aren't any data entry errors, etc.


### Activity

Using the `read_excel()` function from the `readxl` package (install if you need to), load the file `Size_Dimorphism.xlsx` in R. Assign it to the object, `SSD`.

```{r}
# FIXME
SSD <- read_excel("../data/Size_Dimorphism.xlsx")
```

How many rows and columns of data are there?

> 200 rows and 5 columns.


## Number of Observations per Group

This experiment is balanced, meaning there are equal numbers of males and females in each species (50 of each).


#### Activity

Check that this is the case by using `count()` to count the number of individuals by species and sex.

```{r}
# FIXME
SSD |> count(Species, Sex)
```

It looks like something is not right. There are several rows with 1, 2, or 3 observations.

Explain what seems to have happened during data entry.

> There are typos in the names of the species, and Sex has been entered with a mix of upper and lower case.


### Making Corrections

We will fix the `Sex` variable first. Because you currently have a mix of lower and upper case, and we want all uppercase, we can use the built-in `toupper()` function which makes a string all uppercase. There is a similar `tolower()` function, if you happen to want all lower case.

In this chunk, mutate `Sex` using `toupper()`. Overwrite the `SSD` object from above with the output. Then use the same tallying code your wrote above to check that you now only have `F` and `M` in the `Sex` column.

```{r}
## FIXME
SSD <- SSD |>
  mutate(Sex = toupper(Sex))

SSD |>
  count(Species, Sex)
```

You should now see that just two observations of `Species` are incorrect. There are a few ways to "find and replace" strings in R. The `stringr` package, which is loaded automatically as part of the tidyverse has a series of functions that start with `str_` to work with strings (find, replace, subset, etc.).

Have a look through the help files for the `stringr` package to see what all is possible.

We will use `str_replace()` to replace the misspelled names. `str_replace()` has the following basic syntax:

```{r}
zz <- c("x_1", "x_2")
str_replace(zz, "x", "xyz")
```

This code replaces `x` with `xyz`. In the following chunk, overwrite `Species` with a `mutate()`ed version of itself passed through `str_replace()` where you correct the two spellings that are incorrect (you will mutate Species twice, once for each correction). Then use the same code as above to tally the data and check that the four groups now have 50 observations each.

```{r}
## FIXME
SSD <- SSD |>
  mutate(
    Species = str_replace(Species, "Pardosa ramulosa", "Pardosa_ramulosa"),
    Species = str_replace(Species, "Pardosa_ramuloso", "Pardosa_ramulosa")
  )

SSD |>
  count(Species, Sex)

```

Saving yourself the trouble of doing this exercise is one big reason to be careful when you enter data!!

Your data is clean. At this point in the analysis, you could export your cleaned data to a new file. Alternately, you could just have these steps at the beginning of your qmd file with the analysis pipeline and just let me run each time your Rmd file is knitted. Either way would work, and there are benefits to both approaches. With the former, you will have a cleaned version of your data to work with (e.g., import) for later steps in the analysis. This is not ideal because it makes more files to keep track of. With the latter, you will have a full record of the steps you took to clean the data. The downside is that you need to make sure to run all the code each time you knit to be sure to have the corrected data. If you are analyzing data via a set of separate files, this might be impractical (e.g., if your 2nd analysis file needs the cleaned data).


#### Writing Data

One last step, let's write out your new, typo-free data. Look at the help for `write_csv()`, and write out your data to a new csv file named, `Size_Dimorphism_corrected.csv`.

```{r}
# FIXME
write_csv(SSD, "../data/Size_Dimorphism_corrected.csv")
```

Now read your new file back in as if this next section is a new script. Feel free to overwrite your previous object, `SSD`. This is a good idea to avoid confusion. Use `read_csv()`.

We prefer to use `write_csv()`, which is part of tidyverse, to R's built-in `write.csv()` (note _ vs. .). `write_csv()` has some friendlier default settings.

```{r}
# FIXME
SSD <- read_csv(
  "../data/Size_Dimorphism_corrected.csv",
  show_col_types = FALSE
)
```


### Data Filtering

A very common activity when you are analyzing data is to take subsets, be they subsets of rows or one or more columns (or both simultaneously). Gaining experience at this kind of filtering will make you much more efficient.


#### Activity

To give you some practice filtering, filter your data in the following ways using both

1. base R functions
2. tidyverse functions

Verify your results match in each case. You do not need to save the resulting `data.frame`s.

1. All *Pardosa ramulosa*
2. All females of both species
3. Body mass and sex for *Nephila clavipes*
4. Rows 1-50 (either using base R or the `slice()` function from tidyverse [use `?slice` to load the help file])
5. Mass of the largest female (by mass) in each species
6. Male *Pardosa ramulosa* with body lengths less than 4 or greater than 6

```{r}
# FIXME

# We give the base R code and then the tidyverse code
# 1
SSD[SSD$Species == "Pardosa_ramulosa", ]
SSD |> filter(Species == "Pardosa_ramulosa")

# 2
SSD[SSD$Sex == "F", ]
SSD |> filter(Sex == "F")

# 3
SSD[SSD$Species == "Nephila_clavipes", c("BodyMass", "Sex")]
SSD |> filter(Species == "Nephila_clavipes") |> select(BodyMass, Sex)

# 4
SSD[1:50, ]
SSD |> slice(1:50)

# 5
max(SSD[SSD$Sex == 'F' & SSD$Species == 'Pardosa_ramulosa', 'BodyMass'])
max(SSD[SSD$Sex == 'F' & SSD$Species == 'Nephila_clavipes', 'BodyMass'])
SSD |>
  filter(Sex == "F") |>
  group_by(Species) |>
  summarize(max_BodyMass = max(BodyMass))

# 6
SSD[
  SSD$Species == "Pardosa_ramulosa" &
    SSD$Sex == "M" &
    (SSD$BodyLength < 4 | SSD$BodyLength > 6),
]
SSD |>
  filter(Species == "Pardosa_ramulosa" & Sex == "M") |>
  filter(BodyLength < 4 | BodyLength > 6)
```


### Plotting Histograms

To start looking at sexual size dimorphism, we will make some histograms. This is the easiest method to visualize univariate data.


#### Activity

Start with a histogram of body length overall. Follow the code in the lectures if you need to.

```{r}
#| fig-alt: "Histogram of body length for two species of spiders showing a large amount of variation with a large cluster near 0."

# FIXME

ggplot(SSD, aes(BodyLength)) +
  geom_histogram()
```

There are some obvious groupings here, but we don't know which species or sex the clusters represent. We need to separate both species and sex. One approach is to make a plot for each species with `fill` coding for sex (this is analogous to using color, but works with histograms). Try this.

```{r}
#| fig-alt: "Histogram of body length in Pardosa colored by sex showing high overlap."

# FIXME
SSD |>
  filter(Species == 'Pardosa_ramulosa') |>
  ggplot(aes(BodyLength, fill = Sex)) +
  geom_histogram()
```

```{r}
#| fig-alt: "Histogram of body length in Nephila colored by sex showing distinct clusters for female and male."

# FIXME

SSD |>
  filter(Species == 'Nephila_clavipes') |>
  ggplot(aes(BodyLength, fill = Sex)) +
  geom_histogram()
```

We could also visualize all groups with `facet_grid()`. Here is an example:

```{r}
#| fig-alt: "Two by two grid of histograms of body size in Nephila and Pardosa for each sex."
#| eval: true

# FIXME
ggplot(SSD, aes(BodyLength)) +
  geom_histogram() +
  facet_grid(Sex ~ Species)
```

`facet_grid()` can take 1 or two arguments. The argument before `~` splits by rows, and after `~` splits by columns. If you only want one or the other use `.`. See the lecture slides for an example.

With this you can clearly see SSD in *Nephila* but not in *Pardosa*.


### Scatterplot

You might be interested in the relationship between body length and body mass. Scatterplots are the most common way to visualize such bivariate relationships.


#### Activity

Create a scatterplot of body length and body mass. Use color to show `Sex` and facet by `Species.` Put body length on the x-axis. Add axis labels, but don't worry about units for now.

```{r}
#| fig-alt: "Scatter plot of body mass vs. body length facetted by species and colored by sex showing non-linear relationships."

# FIXME
ggplot(SSD, aes(x = BodyLength, y = BodyMass, color = Sex)) +
  geom_point() +
  facet_grid(Species ~ .) +
  labs(x = "Body Length", y = "BodyMass")
```

Describe the patterns you observe. Do you think this is a useful visualization? Why or why not?

> Not really that useful. The data for *Pardosa* is all smashed down to ~0 on the y axis, as is the male data for *Nephila*. The *Nephila* female are the only ones with any variation, which looks like it is increasing as body length increases.

Because body length and body mass are related by an exponential power, if we take advantage of the math of logarithms and log-transform the data, that will linearize the relationship. Ignoring the y-intercepts:

$$Mass \propto Length^b$$
$$\log(Mass) \propto b \log(Length)$$

Make two new variables that are the log10-transformations of body length and body mass using `mutate()` and plot the data again. Look at the help for `mutate` for hints. Then add new axis labels.

```{r}
#| fig-alt: "Scatter plot of body mass vs. body length facetted by species and colored by sex showing linear relationships because the data are plotted on log-log axes."

# FIXME
SSD <- mutate(SSD, logMass = log10(BodyMass), logLength = log10(BodyLength))

# or with a pipe

SSD <- SSD |> mutate(logMass = log10(BodyMass), logLength = log10(BodyLength))

# Scatterplot
library(ggtext)
ggplot(SSD, aes(x = logLength, y = logMass, color = Sex)) +
  geom_point() +
  facet_grid(Species ~ .) +
  labs(
    x = "**log<sub>10</sub> Body Length**",
    y = "**log<sub>10</sub> Body Mass**"
  ) +
  theme(axis.title.x = element_markdown(), axis.title.y = element_markdown())
```

What does this plot tell you? Do you think this is a more effective visualization of the data?

> There is a positive, linear relationship between log(mass) and log(body length). In *Pardosa*, the female and male distributions overlap almost completely. In *Nephila*, there is a large separation between the females and males.

Now add lines of best fit and transparency (`alpha`) to your points.

```{r}
#| fig-alt: "Scatter plot of body mass vs. body length facetted by species and colored by sex showing linear relationships because the data are plotted on log-log axes. Regression lines confirm this relationship."

# FIXME
ggplot(SSD, aes(x = logLength, y = logMass, color = Sex)) +
  geom_point(alpha = 1 / 3) +
  geom_smooth(method = 'lm', formula = 'y ~ x') +
  facet_grid(Species ~ .) +
  labs(
    x = "**log<sub>10</sub> Body Length**",
    y = "**log<sub>10</sub> Body Mass**"
  ) +
  theme(axis.title.x = element_markdown(), axis.title.y = element_markdown())
```

What do these regression lines tell you?

> The slopes of the lines are nearly identical, which suggests that the linear relationships between log length and log mass is probably equal across the four groups. Later in the course we will learn how to specifically test this hypothesis.


## Rainout Experiment

In this next section, we will be practicing data manipulation and exploration. We will work with two files that contain data related to a rainout experiment. Changes in precipitation are commonly predicted with climate change, so rainout experiments are used to examine how different proposed future precipitation conditions (i.e., in our case high or low rain reduction) influences plant species composition and biomass.

The first dataset (`rainout_plots.csv`) describes plot-level data. This experiment contains 8 subplots per plot. Thus these plot-level data contains plot and subplot identities, as well as only a single value per subplot for each of its variables (e.g., light availability, biomass) as these are collected at the subplot level. We will also work with a dataset that contains information about species *within* each subplot called `rainout_plantspecies_presence.csv`. There will be multiple observations per subplot in this dataset because the unique species in each subplot was recorded.

Let's start with the plant composition data.  Read in `rainout_plantspecies_presence.csv` and save it to an object called `comp`. Look at the structure of this tibble.

```{r}
# FIXME
comp <- read_csv(
  "../data/rainout_plantspecies_presence.csv",
  show_col_types = FALSE
)
str(comp)
```


### Summarizing

One very important tool you will learn from the tidyverse is how to summarize your data. We will use the `summarize()` function quite a bit in this course, so let's get some practice. One thing we might want to know about is how many unique species are in each subplot within each plot. That way we can start to make predictions about how rain exclusion influences species richness.  Using `group_by()` and `summarize()`, calculate the number of unique species per subplot within each plot in `comp`. Save the new object as `richness`, and also name the new variable `richness`.  Hint `(length(unique(<variable-of-interest>)))` will give you the number of rows that are unique within the groups you have set, which equates to the number of unique species, or richness, per subplot.


#### Activity

```{r}
# FIXME

richness <- comp |>
  group_by(plot_no, subplot) |>
  summarize(richness = length(unique(species)))
richness

# You can get rid of the message `summarize()` has grouped output
#by 'plot_no' like this:
richness2 <- comp |>
  group_by(plot_no, subplot) |>
  summarize(richness = length(unique(species)), .groups = "drop")
richness2
```


### Joining

One of the most common things you will do in your data cleaning and exploration stage is join datasets together. This will become especially important if you store your data as separate, smaller files. In our case, we need to join our `richness` object with our plot-level information so we can examine how richness changes with our two rainout treatments (e.g., high rain removal and low rain removal).


#### Activity

Read in the plot-level data, and save it to an object called `plot_ids`.

```{r}
# FIXME
plot_ids <- read_csv("../data/rainout_plots.csv", show_col_types = FALSE)
plot_ids
```

As we discussed in lecture, there are many different functions for joining in the tidyverse. We will focus on `left_join()` here because you can use this for most joining you need to do, and switch the order of the datasets you are joining depending on your need. For example, `left_join(d1, d2)` is the same as `right_join(d2, d1)`.

Join your plot level data to your species richness data using `left_join()`. You can save this as the same object that the richness was saved as previously, given this is the data you are building upon. Try doing this in two different ways, one where you specify the columns you want to join by, and one where you don't and let `left_join()` pick the columns that automatically match. This should help you see the power of these joining functions.

```{r}
# FIXME
richness <- richness |>
  left_join(plot_ids, by = join_by(plot_no, subplot))
richness

# Alternately
richness |>
  left_join(plot_ids)
```


### More Summarizing

Along with the minimum, maximum, and range, two of the simplest and most common descriptive statistics are means and standard deviations.


#### Activity

Calculate the mean and standard deviation for species richness for each plot. Use `group_by()` and `summarize()`. Save this as a new object called `mean_richness`.

```{r}
# FIXME
mean_richness <- richness |>
  group_by(plot_no) |>
  summarize(mean = mean(richness), sd = sd(richness))
mean_richness
```

To visualize whether there are consistent differences in richness between rainout treatments, we will plot our data.


#### Activity

Create a graph that shows how rain removal influences the average species richness using a scatter plot.  Color your points by plot number in the `aes()`. Add transparency and/or jitter to make sure you can see all points clearly. Because plots are a category, make sure it is being treated as a factor when you make your plot. Feel free to fix up the axis labels or choose a new color scheme if you wish.

```{r}
# FIXME
ggplot(
  richness,
  aes(x = rain_removal, y = richness, color = factor(plot_no))
) +
  geom_point(position = position_jitter(width = 0.2), alpha = 1 / 2)

```

With a scatterplot and this number of plots, it is difficult to see the trends per plot. Let's try a boxplot instead. Use `geom_boxplot` and specify different colors for different plot numbers in the `aes()`.


```{r}
# FIXME

ggplot(
  richness,
  aes(x = rain_removal, y = richness, color = factor(plot_no))
) +
  geom_boxplot()

```

Notice how setting `color =` in the aesthetics causes ggplot to split the data into groups automatically and apply separate lines or boxplots to those data. This is a very powerful feature of ggplot that makes it possible to generate very complex plots very easily. In contrast, imagine doing 12 separate linear regressions, adding them one by one to the plot and keeping track of all their different colors.


## AI Statement

Please indicate whether you used any generative AI tools to help you with this problem set and explain how you used these. An example of how to structure this statement is below. If you did not use generative AI, you can simply state: "I did not use AI for this problem set."

Example statement structure: "I acknowledge the use of AI in completing this assignment and would like to provide a brief explanation of how I utilized AI, specifically [LLM], as a tool to support my work. For this assignment, I employed [LLM] to [describe the specific purpose or task]. To do so I crafted the following prompts: [List prompts used]"

>

